/*
** Copyright Glaber
**
** This program is free software; you can redistribute it and/or modify
** it under the terms of the GNU General Public License as published by
** the Free Software Foundation; either version 2 of the License, or
** (at your option) any later version.
**
** This program is distributed in the hope that it will be useful,
** but WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
** GNU General Public License for more details.
**
** You should have received a copy of the GNU General Public License
** along with this program; if not, write to the Free Software
** Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
**/

#include "glb_state.h"
#include "glb_state_interfaces.h"
#include "zbxjson.h"
#include "zbxavailability.h"

#define INTERFACE_FAILS_TO_FAIL 3

typedef struct {
    elems_hash_t *interfaces; //interfaces refernced by interface objects
    elems_hash_t *typed_interfaces; //interfaces referenced by type and communication name, f.e: type: icmp, addr: 10.100.10.118
                                    //such interfaces id is generated by placing it's name to strpool and using the address
    elems_hash_t *ip_to_host_index;

    mem_funcs_t memf;
    strpool_t strpool;

} interfaces_conf_t;

static interfaces_conf_t *conf = NULL; 

typedef struct {
    int lastchange;
    const char *error;
    unsigned char oper_state;
    unsigned char type;
    unsigned char new_state_count;
} interface_state_t;
    

ELEMS_CREATE(interface_create_cb) {
    elem->data = memf->malloc_func(NULL, sizeof(interface_state_t));
    interface_state_t* ifstate = elem->data;
    
    bzero(ifstate, sizeof(interface_state_t));
    ifstate->lastchange = time(NULL);
    ifstate->new_state_count = 0;
    ifstate->oper_state = INTERFACE_AVAILABLE_UNKNOWN;
    ifstate->error = strpool_add(&conf->strpool, "There was no activity on interface since startup");
}

ELEMS_FREE(interface_free_cb) {
    interface_state_t *ifstate = elem->data;
    
    strpool_free(&conf->strpool, ifstate->error);
    memf->free_func(ifstate);
    elem->data = NULL;
}


ELEMS_CREATE(ip_to_host_create_cb) {
    elem->data = 0;
}

ELEMS_FREE(ip_to_host_free_cb) {
    strpool_free(&conf->strpool, (char *)elem->id);
}

int glb_state_interfaces_init(mem_funcs_t *memf)
{
    if (NULL == (conf = memf->malloc_func(NULL, sizeof(interfaces_conf_t)))) {
        LOG_WRN("Cannot allocate memory for cache struct");
        exit(-1);
    };
    
    conf->interfaces = elems_hash_init(memf, interface_create_cb, interface_free_cb );
    conf->ip_to_host_index = elems_hash_init(memf, ip_to_host_create_cb, ip_to_host_free_cb );
    conf->memf = *memf;
    strpool_init(&conf->strpool,memf);
    
    return SUCCEED;
}

int glb_state_interfaces_destroy() {
    elems_hash_destroy(conf->interfaces);
    strpool_destroy(&conf->strpool);
}

typedef struct {
    const char *ip;
    u_int64_t hostid;
} ip_to_host_info_t;


ELEMS_CALLBACK(register_ip_cb) {
    ip_to_host_info_t* ip_to_host = data;
    elem->data = (void *)ip_to_host->hostid;
    strpool_copy((char * )elem->id);
}

ELEMS_CALLBACK(find_ip_cb) {
  
    ip_to_host_info_t* ip_to_host = data;
    ip_to_host->hostid = (u_int64_t)elem->data;
    ip_to_host->ip = (char *)elem->id;
  
    return SUCCEED;
}

int glb_state_interfaces_register_ip(const char *addr, u_int64_t hostid) {
    if (NULL == addr || 0 == hostid)
        return FAIL;

    ip_to_host_info_t ip_to_host = {.ip = strpool_add(&conf->strpool, addr), .hostid = hostid};
  
    elems_hash_process(conf->ip_to_host_index, (u_int64_t)ip_to_host.ip, register_ip_cb, &ip_to_host, 0);
    strpool_free(&conf->strpool, ip_to_host.ip);
  
    return SUCCEED;
}

u_int64_t   glb_state_interfaces_find_host_by_ip(const char *addr) {
    if (NULL == addr)
        return 0;

    ip_to_host_info_t ip_to_host = {.ip = strpool_add(&conf->strpool, addr), .hostid = 0};
  
    if (SUCCEED == elems_hash_process(conf->ip_to_host_index, (u_int64_t)ip_to_host.ip, find_ip_cb, &ip_to_host, ELEM_FLAG_DO_NOT_CREATE )) {
        strpool_free(&conf->strpool, ip_to_host.ip);
        return ip_to_host.hostid;
    }
    
    strpool_free(&conf->strpool, ip_to_host.ip);
    return 0;
}

void glb_state_interfaces_release_ip(const char *addr) {
    const char *id = strpool_add(&conf->strpool, addr);
    elems_hash_delete(conf->ip_to_host_index, (u_int64_t)id );
    strpool_free(&conf->strpool, id);
}


ELEMS_CALLBACK(register_iface_fail) {
    interface_state_t *iface = elem->data;

    if (iface->oper_state != INTERFACE_AVAILABLE_FALSE && 
        iface->new_state_count++ < INTERFACE_FAILS_TO_FAIL)
        return SUCCEED;

    iface->oper_state = INTERFACE_AVAILABLE_FALSE;
    iface->lastchange = time(NULL);
    strpool_free(&conf->strpool, iface->error);
    iface->error = strpool_add(&conf->strpool, (char *)data);
    iface->new_state_count = 0;
}

//normal  ifaces
int  glb_state_interfaces_register_fail(u_int64_t id, const char *error) {
    if (0 == id)
        return FAIL;

    elems_hash_process(conf->interfaces, id, register_iface_fail, (void *)error, 0 );
    return SUCCEED;
}

ELEMS_CALLBACK(register_iface_ok) {
    interface_state_t *iface = elem->data;
    
    iface->oper_state = INTERFACE_AVAILABLE_TRUE;
    iface->lastchange = time(NULL);
    strpool_free(&conf->strpool, iface->error);
    iface->error = strpool_add(&conf->strpool, (char *)data);
    iface->new_state_count = 0;
}

int  glb_state_interfaces_register_ok(u_int64_t id, const char *error) {
    if (0 == id)
        return FAIL;

    elems_hash_process(conf->interfaces, id, register_iface_ok, (void *)error, 0);
    return SUCCEED;
}

ELEMS_CALLBACK(get_iface_info) {
    interface_state_t *iface = elem->data;
    glb_state_interface_info_t *info = data;
    zbx_free(info->error);

    info->avail = iface->oper_state;
    info->lastchange = iface->lastchange;
    if (NULL == iface->error) 
        info->error = NULL;
    else 
        info->error = zbx_strdup(NULL, iface->error);
}

glb_state_interface_info_t *glb_state_interfaces_get_avail(u_int64_t id) {
    static glb_state_interface_info_t info = {0};
    if (0 == id)
        return NULL;
    
    if (FAIL == elems_hash_process(conf->interfaces, id, get_iface_info, &info, ELEM_FLAG_DO_NOT_CREATE))
        return NULL;
    
    return &info;
}

ELEMS_CALLBACK(interface_get_json) {
    struct zbx_json *json = data;
    interface_state_t *iface = elem->data;

    zbx_json_addobject(json, NULL); 
    zbx_json_addint64(json, "id", elem->id);
    zbx_json_addint64(json, "avail", iface->oper_state);
    zbx_json_addint64(json, "lastchange", iface->lastchange);
    zbx_json_addstring(json, "error", iface->error, ZBX_JSON_TYPE_STRING);
    zbx_json_close((struct zbx_json *)data);
}

int glb_state_interfaces_get_state_json(zbx_vector_uint64_t *ids, struct zbx_json *json) 
{
    int i;
   
    zbx_json_addarray(json, ZBX_PROTO_TAG_DATA);
    
    for (i=0; i < ids->values_num; i++) {
        elems_hash_process(conf->interfaces, ids->values[i], interface_get_json, json, ELEM_FLAG_DO_NOT_CREATE);
    }

    zbx_json_close(json); 
}